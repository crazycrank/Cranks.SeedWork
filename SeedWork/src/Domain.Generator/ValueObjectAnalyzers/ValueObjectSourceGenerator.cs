using System.Collections.Immutable;
using System.Text;

using Cranks.SeedWork.Domain.Generator.Extensions;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cranks.SeedWork.Domain.Generator.ValueObjectAnalyzers;

[Generator]
public class ValueObjectSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // TODO read https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md
        var valueObjects = context.SyntaxProvider
                                  .CreateSyntaxProvider(CouldBeValueObject, GetSymbol)
                                  .Where(type => type is not null)
                                  .Collect();

        context.RegisterSourceOutput(valueObjects, GenerateCode!);
    }

    private static bool CouldBeValueObject(SyntaxNode node, CancellationToken cancellationToken)
    {
        if (node is not AttributeSyntax attribute)
        {
            return false;
        }

        if (attribute.Name.ExtractName() is not ("ValueObject" or "ValueObjectAttribute"))
        {
            return false;
        }

        if (attribute.GetAttributeNode() is not RecordDeclarationSyntax rds)
        {
            return false;
        }

        if (!rds.IsPartial())
        {
            return false;
        }

        ////if (!rds.IsSubTypeOf("ValueObject"))
        ////{
        ////    return false;
        ////}

        return true;
    }

    private static ITypeSymbol? GetSymbol(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        if (attributeSyntax.GetAttributeNode() is not RecordDeclarationSyntax rds)
        {
            return null;
        }

        var declaredSymbol = context.SemanticModel.GetDeclaredSymbol(rds, cancellationToken);
        return declaredSymbol is not ITypeSymbol symbol || !symbol.IsValueObject()
                   ? null
                   : symbol;
    }

    private static void GenerateCode(SourceProductionContext context,
                                     ImmutableArray<ITypeSymbol> valueObjects)
    {
        foreach (var valueObject in valueObjects)
        {
            var code = GenerateCode(valueObject);
            var typeNamespace = valueObject.ContainingNamespace.IsGlobalNamespace
                                    ? null
                                    : $"{valueObject.ContainingNamespace}.";

            context.AddSource($"{typeNamespace}{valueObject.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(ITypeSymbol valueObjectTypeSymbol)
    {
        var isUnary = true;
        string? unaryParameterName = null;
        string? unaryType = null;
        foreach (var dcs in valueObjectTypeSymbol.DeclaringSyntaxReferences)
        {
            if (dcs.GetSyntax() is RecordDeclarationSyntax { ParameterList.Parameters: { Count: >= 1 } parameters })
            {
                isUnary = parameters.Count == 1;
                unaryParameterName = parameters.Single().Identifier.Text;
                unaryType = parameters.Single().Type.ExtractTypeName();
            }
        }

        var valueObjectName = valueObjectTypeSymbol.Name;
        var code = new StringBuilder();
        code.AppendLine("// <auto-generated />");
        code.AppendLine();

        if (!valueObjectTypeSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            code.AppendLine($"namespace {valueObjectTypeSymbol.ContainingNamespace};");
            code.AppendLine();
        }

        code.AppendLine("using Cranks.SeedWork.Domain;");
        code.AppendLine();

        code.AppendLine($"partial record {valueObjectName}");

        if (!isUnary)
        {
            code.AppendLine($"    : ValueObject<{valueObjectName}>;");
        }
        else
        {
            code.AppendLine($"    : ValueObjectUnary<{unaryType}, {valueObjectName}>({unaryParameterName})");
            code.AppendLine("{");
            //// TODO Implement useful members
            code.AppendLine("}");
        }

        return code.ToString();
    }
}
